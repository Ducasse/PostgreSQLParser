tests
testBigSelectCommands
	self
		parse: 'SELECT affectation.debut AS debutaffectation, affectation.fin AS finaffectation FROM affectation,support,personne WHERE affectation.cle_support = support.cle AND	support.cle_personne = personne.cle AND personne.cle = clepersonne AND	affectation.cle_equipe = cleequipe AND affectation.fin <= finperiode ORDER BY affectation.debut' rule: #selectCommand;
		parse: 'SELECT * FROM membres(labo,dateobservation::DATE,dateobservation::DATE) AS ( clepersonne INTEGER, datearrivee DATE, sexe VARCHAR, nompersonne VARCHAR, prenompersonne VARCHAR, datenaissance DATE, paysorigine VARCHAR, nomcategorie VARCHAR, corps VARCHAR, typedusupport VARCHAR, numsection INT2, numcmu INT2, debutsupport DATE, finsupport DATE, nomequipes TEXT, nomemployeur VARCHAR, nomenseignement VARCHAR, typefinancement VARCHAR, financeurs TEXT, reffinancement VARCHAR, responsablethese TEXT )' rule: #selectCommand;
		parse: 'SELECT  clepersonne,  datearrivee,  sexe,  nompersonne,  prenompersonne,  datenaissance,  paysorigine,  nomcategorie,  corps,  typedusupport,  numsection,  numcmu,  debutsupport,  finsupport,  agt_genere_liste (equipe_avec_repartition(nomequipe, repartition)) AS nomequipes,  nomemployeur,  nomenseignement,  typefinancement,  financeurs,  reffinancement,  responsablethese  FROM "vue_liste_personnel_affectations"  WHERE  labo_personne(clepersonne,debut::DATE) = labo  AND		est_dans_interval(debut,fin,debutsupport,finsupport)  AND		est_dans_interval(debut,fin,debutaffectation,finaffectation)  GROUP BY  clepersonne,  datearrivee,  sexe,  nompersonne,  prenompersonne,  datenaissance,  paysorigine,  nomcategorie,  corps,  typedusupport,  numsection,  numcmu,  debutsupport,  finsupport,  nomemployeur,  nomenseignement,  typefinancement,  financeurs,  reffinancement,  responsablethese' rule: #selectCommand;
		parse: 'SELECT calcule_age(datenaissance,dateobservation::date)::INTEGER AS age, SUM(est_un_homme(civilite))::INTEGER AS homme, SUM(est_une_femme(civilite))::INTEGER AS femme FROM personne,support WHERE personne.cle = support.cle_personne AND (support.debut <= dateobservation AND (support.fin >= dateobservation OR support.fin IS NULL)) AND datenaissance IS NOT NULL GROUP BY age ORDER BY age' rule: #selectCommand;
	parse: 'SELECT support.cle, support.debut, support.fin FROM support WHERE support.cle_personne = clepersonne' rule: #selectCommand;
	parse: 'SELECT personne.cle, (((personne.nom)::text || '' ''::text) || (personne.prenom)::text) AS nomprenom FROM personne ORDER BY personne.nom, personne.prenom' rule: #selectCommand;
	parse: 'SELECT personne.nom AS nompersonne, personne.prenom, affectation.cle_equipe, support.cle_personne, equipe.nom AS nomequipe FROM personne, support, affectation, equipe WHERE ((((equipe.cle = affectation.cle_equipe) AND ((affectation.debut <= now()) AND ((affectation.fin >= now()) OR (affectation.fin IS NULL)))) AND (affectation.cle_support = support.cle)) AND (support.cle_personne = personne.cle))' rule: #selectCommand;
	parse: 'SELECT localisation.cle_personne AS clepersonne, ((((((((((((''<a href="''::text || (genere_url_carto(localisation.cle_batiment, localisation.bureau))::text) || ''" target="_blank">''::text) || (site.nom)::text) || ''<br>''::text) || (batiment.nom)::text) || ''<br>''::text) || (affiche_etage(localisation.etage))::text) || ''Bureau ''::text) || (localisation.bureau)::text) || ''</a><br>''::text) || (localisation.telephone)::text) || ''<br>''::text) AS emplacement FROM localisation, site, batiment WHERE (((localisation.visible = true) AND (localisation.cle_batiment = batiment.cle)) AND (batiment.cle_site = site.cle))' rule: #selectCommand;
	parse: 'SELECT personne.cle, (((personne.nom)::text || '' ''::text) || (personne.prenom)::text) AS nomprenom FROM personne ORDER BY personne.nom, personne.prenom' rule: #selectCommand;
	parse: 'SELECT personne.cle, personne.nom, personne.prenom FROM personne WHERE (personne.cle IN (SELECT these.cle_coencadrant FROM these))' rule: #selectCommand;
	parse: 'SELECT equipe.cle AS cleequipe, personne.nom AS nompersonne, personne.prenom AS prenompersonne, equipe.nom AS nomequipe, equipe.debut AS debutequipe, equipe.fin AS finequipe, affectation.debut AS debutaffectation, affectation.fin AS finaffectation FROM affectation, equipe, support, personne WHERE ((((affectation.cle_equipe = equipe.cle) AND (((affectation.debut > equipe.fin) OR (affectation.debut < equipe.debut)) OR (affectation.fin > equipe.fin))) AND (affectation.cle_support = support.cle)) AND (support.cle_personne = personne.cle))' rule: #selectCommand;
	parse: 'SELECT civilite.civilite AS sexe, personne.nom AS nompersonne, personne.prenom, personne.datenaissance, grade.grade AS corps, typesupport.nature AS typecontrat, support.debut AS debutsupport, support.fin AS finsupport, employeur.nom AS nomemployeur, these.fin AS finthese, these.abandon AS abandonthese FROM (((personne LEFT JOIN these ON ((personne.cle = these.cle_personne))) LEFT JOIN civilite ON ((personne.civilite = civilite.cle))) LEFT JOIN support ON ((support.cle_personne = personne.cle))), grade, typesupport, employeur WHERE ((((support.cle_grade = grade.cle) AND (support.cle_typesupport = typesupport.cle)) AND (support.cle_employeur = employeur.cle)) AND ((grade.cle = 27) OR (grade.cle = 17)))' rule: #selectCommand;
	parse: 'SELECT financements.clesupport, financements.reffinancement, financements.typefinancement, agt_genere_liste((financements.financeurs)::text) AS financeurs FROM (SELECT support.cle AS clesupport, support.financement AS reffinancement, typefinancement.type AS typefinancement, employeur.nom AS financeurs, r_supfin.principal FROM (((support LEFT JOIN r_supfin ON ((support.cle = r_supfin.cle_support))) LEFT JOIN employeur ON ((r_supfin.cle_financeur = employeur.cle))) LEFT JOIN typefinancement ON ((support.cle_typefinancement = typefinancement.cle))) ORDER BY support.cle, r_supfin.principal DESC) financements GROUP BY financements.clesupport, financements.reffinancement, financements.typefinancement' rule: #selectCommand;
	parse: 'SELECT personne.cle AS clepersonne, personne.nom AS nompersonne, personne.prenom, personne.datenaissance, equipe.nom AS nomequipe, support.cle_typesupport, support.debut AS debutsupport, support.fin AS finsupport, vue_financements_des_supports.typefinancement, employeur.nom AS nomemployeur, vue_financements_des_supports.financeurs, vue_financements_des_supports.reffinancement, aff_date_fin_these(date(these.fin), these.abandon) AS txtfinthese, date(these.fin) AS finthese, these.abandon AS abandonthese, affectation.debut AS debutaffectation, affectation.fin AS finaffectation, e2.nom AS cotutelle, typesupport.nature AS typesupport FROM (personne LEFT JOIN these ON ((personne.cle = these.cle_personne))), (support LEFT JOIN employeur e2 ON ((support.cle_cotutelle = e2.cle))), affectation, employeur, equipe, vue_financements_des_supports, typesupport WHERE (((((((support.cle_personne = personne.cle) AND (support.cle_grade = 8)) AND (support.cle_employeur = employeur.cle)) AND (support.cle = vue_financements_des_supports.clesupport)) AND (support.cle = affectation.cle_support)) AND (equipe.cle = affectation.cle_equipe)) AND (support.cle_typesupport = typesupport.cle))' rule: #selectCommand;
	parse: 'SELECT support.cle AS clesupport, employeur.nom AS nomemployeur FROM (support JOIN employeur ON ((employeur.cle = support.cle_employeur)))' rule: #selectCommand;
	parse: 'SELECT personne.cle AS clepersonne, civilite.civilite AS sexe, personne.nom AS nompersonne, personne.prenom AS prenompersonne, enseignement.entite AS nomenseignement, employeur.nom AS nomemployeur, support.debut AS debutsupport, support.fin AS finsupport, grade.grade AS statut FROM (((((personne JOIN civilite ON ((personne.civilite = civilite.cle))) JOIN support ON ((support.cle_personne = personne.cle))) LEFT JOIN enseignement ON ((support.cle_enseignement = enseignement.cle))) JOIN employeur ON ((support.cle_employeur = employeur.cle))) JOIN grade ON ((support.cle_grade = grade.cle))) WHERE (((grade.cle_catgrade)::text = ''MCF''::text) OR ((grade.cle_catgrade)::text = ''PR''::text))' rule: #selectCommand;
	parse: 'SELECT date_part(''year''::text, support.debut) AS annee, count(*) AS total, (sum(est_un_homme(personne.civilite)))::integer AS homme, (sum(est_une_femme(personne.civilite)))::integer AS femme FROM personne, support WHERE ((personne.cle = support.cle_personne) AND (date_part(''year''::text, support.debut) IN (SELECT DISTINCT date_part(''year''::text, support.debut) AS annee FROM support ORDER BY date_part(''year''::text, support.debut)))) GROUP BY date_part(''year''::text, support.debut) ORDER BY date_part(''year''::text, support.debut)' rule: #selectCommand;
	parse: 'SELECT personne.cle AS clepersonne, personne.nom AS nompersonne, personne.prenom, personne.datenaissance, grade.grade, employeur.nom AS nomemployeur, support.debut AS debutsupport, support.fin AS finsupport FROM personne, support, grade, categorie, employeur WHERE (((((((personne.cle = support.cle_personne) AND (support.cle_grade = grade.cle)) AND (support.cle_categorie = categorie.cle)) AND ((categorie.categorie)::text = ''PERMANENT''::text)) AND (support.cle_employeur = employeur.cle)) AND (((((support.cle_employeur = 1) OR (support.cle_employeur = 15)) OR (support.cle_employeur = 2)) OR (support.cle_employeur = 3)) OR (support.cle_employeur = 107))) AND ((grade.cle_catgrade)::text = ANY (ARRAY[(''IG''::character varying)::text, (''TECH''::character varying)::text])))' rule: #selectCommand